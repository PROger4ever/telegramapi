package tlc

import (
	"bytes"
	"fmt"
	"go/format"
	"log"

	"github.com/andreyvit/telegramapi/tl/tlschema"
)

type Options struct {
	PackageName string
	SkipPrelude bool
}

func GenerateGoCode(sch *tlschema.Schema, options Options) string {
	rm := NewReprMapper(sch)
	rm.Finalize()

	buf := new(bytes.Buffer)

	if !options.SkipPrelude {
		// recognized by GitHub's Linguist and matches Rob Pike's proposal at https://github.com/golang/go/issues/13560
		buf.WriteString("// Code generated by tlc (github.com/andreyvit/telegramapi/tl/cmd/tlc). DO NOT EDIT.\n")
		buf.WriteString("package ")
		buf.WriteString(options.PackageName)
		buf.WriteString("\n")

		var imports []string
		imports = append(imports, "github.com/andreyvit/telegramapi/tl")
		imports = append(imports, rm.GoImports()...)
		importsSet := make(map[string]bool)

		buf.WriteString("\n")
		buf.WriteString("import(\n")
		for _, s := range imports {
			if !importsSet[s] {
				importsSet[s] = true
				buf.WriteString("\t\"" + s + "\"\n")
			}
		}
		buf.WriteString(")\n")

		idx := 0
		prevOrigin := ""
		for _, comb := range sch.Combs() {
			if comb.IsInternal {
				continue
			}

			if comb.Origin != prevOrigin {
				if idx > 0 {
					buf.WriteString(")\n")
				}
				buf.WriteString("\n")
				buf.WriteString("// from ")
				buf.WriteString(comb.Origin)
				buf.WriteString("\n")
				buf.WriteString("const (\n")
				prevOrigin = comb.Origin
				idx = 0
			}
			// if comb.Tag == 0 {
			// 	continue
			// }
			buf.WriteString("\t")
			buf.WriteString(IDConstName(comb))
			if idx == 0 {
				buf.WriteString(" uint32")
			}
			buf.WriteString(" = ")
			buf.WriteString(fmt.Sprintf("0x%08x", comb.Tag))
			buf.WriteString("\n")
			idx++
		}
		buf.WriteString(")\n")
	}

	rm.AppendGoDefs(buf, CodeGenOptions{
		SkipUtil:     options.SkipPrelude,
		SkipSwitch:   options.SkipPrelude,
		SkipComments: options.SkipPrelude,
	})

	if false {
		log.Printf("All type IDs:")
		for i, s := range rm.AllTypeIDs() {
			log.Printf("%03d. %s", i, s)
		}
	}

	src := buf.Bytes()
	fmt, err := format.Source(src)
	if err != nil {
		log.Println(string(src))
		panic(err)
	}
	return string(fmt)
}
